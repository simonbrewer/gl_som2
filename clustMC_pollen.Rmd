---
title: "SOM Markov Chain"
author: "Simon Brewer"
date: "6/18/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load data and libraries

```{r}
require(markovchain)
require(kohonen)
require(RColorBrewer)
load("largeSOM.RData")
```

Make a matrix of site cluster allocations. Loop through the data frame `clus.df` made in the `runSOM.R` script and add the cluster for that particular node to the samples in the node:

```{r}
ages.uniq = unique(sort(ages))
nages = length(ages.uniq)

sitesn.uniq = levels(clus.df$site)
nsites = dim(sites)[1]

poll.clus.mat = matrix(NA, nrow = nages, ncol = nsites)

for (i in 1:dim(clus.df)[1]) {
  siteID = which(sitesn.uniq == clus.df$site[i])
  ageID = which(ages.uniq == clus.df$ages[i])
  
  poll.clus.mat[ageID, siteID] <- clus.df$cluster[i]
}
```

All done? Good. Now fit a Markov Chain by MLE and visualize:
```{r}
clusts.mc = markovchainFit(as.data.frame(poll.clus.mat[,1:20]))
clusts.mc$estimate
```

```{r}
w <- t(clusts.mc$estimate@transitionMatrix)
w <- w[which(w>0)]
plot(clusts.mc$estimate, edge.arrow.size=0.5, 
     edge.label.cex=0.1, edge.curved=0.2, edge.width=w*10,
     vertex.size=20, vertex.color=2)
```

```{r echo=FALSE}
pdf("somMC_pollen.pdf")
plot(clusts.mc$estimate, edge.arrow.size=0.5, 
     edge.label.cex=0.7, edge.curved=0.2)
dev.off()
pdf("somMC_pollen_2.pdf")
plot(clusts.mc$estimate, edge.arrow.size=0.5, 
     edge.label.cex=0.1, edge.curved=0.2, edge.width=w*10,
     vertex.size=20)
dev.off()
```

Convert to igraph
```{r}
require(RColorBrewer)
my.pal = brewer.pal(6, "Dark2")
g <- as(clusts.mc$estimate, "igraph")
min <- 0.5
w <- clusts.mc$estimate@transitionMatrix
w <- w[which(w>0)]
plot(g, edge.label=NA, edge.arrow.size=0.5, 
     edge.label.cex=0.7, edge.curved=0.2, 
     edge.width=w*10, vertex.color = my.pal)
pdf("somMC_pollen_3.pdf")
plot(g, edge.label=NA, edge.arrow.size=0.5, 
     edge.label.cex=0.7, edge.curved=0.2, 
     edge.width=w*10, vertex.color = my.pal)
dev.off()
```

```{r}
# communicatingClasses(clusts.mc$estimate)
# recurrentClasses(clusts.mc$estimate)
# absorbingStates(clusts.mc$estimate)
# transientStates(clusts.mc$estimate)
steadyStates(clusts.mc$estimate)
# canonicForm(clusts.mc$estimate)
# period(clusts.mc$estimate)
```